---
title: "Data analysis pipelines with GNU Make"
---

## Learning Objectives {.unnumbered}

{{< include ../learning_objectives/180-pipelines-make.qmd >}}


## GNU Make as a data analysis pipeline tool

We previously built a data analysis pipeline by using a shell script (we called it `run_all.sh`) to piece together and create a record of all the scripts and arguments we used in our analysis. That is a step in the right direction, but there were a few unsatisfactory things about this strategy:

  1. It takes time to manually erase all intermediate and final files generated by analysis to do a complete test to see that everything is working from top to bottom
  2. It runs every step every time. This can be problematic if some steps take a long time and you have only changed other, smaller parts of the analysis

Thus, to improve on this we are going to use the build and automation tool, Make, to make a smarter
data analysis pipeline.

## Makefile Structure

Each block of code in a Makefile is called a rule, it looks something like this:

```makefile
file_to_create.png : data_it_depends_on.dat script_it_depends_on.py
	python script_it_depends_on.py data_it_depends_on.dat file_to_create.png
```

* `file_to_create.png` is a target, a file to be created, or built.
* `data_it_depends_on.dat` and `script_it_depends_on.py` are dependencies, files which are needed to build or update the target. Targets can have zero or more dependencies.
* `:` separates targets from dependencies.
* `python script_it_depends_on.py data_it_depends_on.dat file_to_create.png` is an action, a command to run to build or update the target using the dependencies. Targets can have zero or more actions. Actions are indented using the TAB character, not 8 spaces.
* Together, the target, dependencies, and actions form a rule.

## Structure if you have multiple targets from a scripts

```makefile
file_to_create_1.png file_to_create_2.png : data_it_depends_on.dat script_it_depends_on.py
	python script_it_depends_on.py data_it_depends_on.dat file_to_create
```

:::{.exercise title="Building a Data Analysis pipeline using Make, a tutorial"}

adapted from [Software Carpentry](http://software-carpentry.org/)

#### Set-up instructions

1. Click the green “Use this template” button from [this GitHub repository](https://github.com/ttimbers/data-analysis-pipeline-make-practice) to obtain a copy of it for yourself (do not fork it).

2. Clone this repository to your computer.

Good reference: http://swcarpentry.github.io/make-novice/reference

Create a file, called `Makefile`, with the following content:

```makefile
# Count words.
results/isles.dat : data/isles.txt src/wordcount.py
	python scripts/wordcount.py \
		--input_file=data/isles.txt \
		--output_file=results/isles.dat
```

This is a simple build file, which for
GNU Make is called a `Makefile` - a file executed
by GNU Make. Let us go through each line in turn:

* `#` denotes a *comment*. Any text from `#` to the end of the line is
  ignored by Make.
* `results/isles.dat` is a [target](http://swcarpentry.github.io/make-novice/reference#target), a file to be
  created, or built.
* `data/isles.txt` and `scripts/wordcount.py` are [dependencies](http://swcarpentry.github.io/make-novice/reference#dependency), a
  file that is needed to build or update the target. Targets can have
  zero or more dependencies.
* `:` separates targets from dependencies.
* `python scripts/wordcount.py --input_file=data/isles.txt --output_file=results/isles.dat` is an
  [action](http://swcarpentry.github.io/make-novice/reference#action), a command to run to build or update
  the target using the dependencies. Targets can have zero or more
  actions.
* Actions are indented using the TAB character, *not* 8 spaces. This
  is a legacy of Make's 1970's origins.
* Together, the target, dependencies, and actions form a
  [rule](http://swcarpentry.github.io/make-novice/reference#rule).

Our rule above describes how to build the target `results/isles.dat` using the
action `python scripts/wordcount.py` and the dependency `data/isles.txt`.

By default, Make looks for a Makefile, called `Makefile`, and we can
run Make as follows:

```bash
$ make results/isles.dat
```

Make prints out the actions it executes:

```bash
python scripts/wordcount.py --input_file=data/isles.txt --output_file=results/isles.dat
```

If we see,

```sh
Makefile:3: *** missing separator.  Stop.
```

then we have used a space instead of a TAB characters to indent one of
our actions.

We don't have to call our Makefile `Makefile`. However, if we call it
something else we need to tell Make where to find it. This we can do
using `-f` flag. For example:

```bash
$ make -f Makefile results/isles.dat
```

As we have re-run our Makefile, Make now informs us that:

```sh
make: `results/isles.dat' is up to date.
```

This is because our target, `results/isles.dat`, has now been created, and
Make will not create it again. To see how this works, let's pretend to
update one of the text files. Rather than opening the file in an
editor, we can use the shell `touch` command to update its timestamp
(which would happen if we did edit the file):

```bash
$ touch data/isles.txt
```

If we compare the timestamps of `data/isles.txt` and `results/isles.dat`,

```bash
$ ls -l data/isles.txt results/isles.dat
```

then we see that `results/isles.dat`, the target, is now older
than`data/isles.txt`, its dependency:

```sh
-rw-r--r--    1 mjj      Administ   323972 Jun 12 10:35 books/isles.txt
-rw-r--r--    1 mjj      Administ   182273 Jun 12 09:58 isles.dat
```

If we run Make again,

```bash
$ make results/isles.dat
```

then it recreates `results/isles.dat`:

```bash
python src/wordcount.py data/isles.txt results/isles.dat
```

When it is asked to build a target, Make checks the 'last modification
time' of both the target and its dependencies. If any dependency has
been updated since the target, then the actions are re-run to update
the target.

We may want to remove all our data files so we can explicitly recreate
them all. We can introduce a new target, and associated rule, `clean`:

```makefile
# Count words.
results/isles.dat : data/isles.txt src/wordcount.py
	python scripts/wordcount.py \
        --input_file=data/isles.txt \
        --output_file=results/isles.dat

clean :
	rm -f results/isles.dat
```

This is an example of a rule that has no dependencies. `clean` has no
dependencies on any `.dat` file as it makes no sense to create these
just to remove them. We just want to remove the data files whether or
not they exist. If we run Make and specify this target,

```makefile
$ make clean
```

then we get:

```bash
rm -f *.dat
```

There is no actual thing built called `clean`. Rather, it is a
short-hand that we can use to execute a useful sequence of
actions.

Let's add another rule to the end of `Makefile`:

```makefile
results/isles.dat : data/isles.txt scripts/wordcount.py
	python scripts/wordcount.py \
        --input_file=data/isles.txt \
        --output_file=results/isles.dat

results/figure/isles.png : results/isles.dat scripts/plotcount.py
	python scripts/plotcount.py \
        --input_file=results/isles.dat \
        --output_file=results/figure/isles.png

clean :
	rm -f results/isles.dat
	rm -f results/figure/isles.png
```

the new target `isles.png` depends on the target `isles.dat`. So to make both, we can simply
type:

```bash
$ make results/figure/isles.png
$ ls
```

Let's add another book:

```makefile
results/isles.dat : data/isles.txt scripts/wordcount.py
	python scripts/wordcount.py \
        --input_file=data/isles.txt \
        --output_file=results/isles.dat

results/abyss.dat : data/abyss.txt scripts/wordcount.py
python scripts/wordcount.py \
    --input_file=data/abyss.txt \
    --output_file=results/abyss.dat

results/figure/isles.png : results/isles.dat scripts/plotcount.py
	python scripts/plotcount.py \
        --input_file=results/isles.dat \
        --output_file=results/figure/isles.png

results/figure/abyss.png : results/abyss.dat scripts/plotcount.py
    python scripts/plotcount.py \
        --input_file=results/abyss.dat \
        --output_file=results/figure/abyss.png

clean :
	rm -f results/isles.dat \
        results/abyss.dat
	rm -f results/figure/isles.png \
        results/figure/abyss.png
```

To run all of the commands, we need to type make <TARGET> for each one:

```bash
$ make results/figure/isles.png
$ make results/figure/abyss.png
```

OR we can add a target `all` to the very top of the `Makefile`
which will build the last of the dependencies.

```makefile
all: results/figure/isles.png results/figure/abyss.png
```
:::

## Finish off the Makefile!

Since we will also combine the figures into a report in the end,
we will change our all target to being the rendered report file,
and add a target for the rendered report file at the end:

```makefile
# Makefile
# Tiffany Timbers, Nov 2018

# This driver script completes the textual analysis of
# 3 novels and creates figures on the 10 most frequently
# occuring words from each of the 3 novels. This script
# takes no arguments.

# example usage:
# make all

all : report/count_report.html

# count the words
results/isles.dat : data/isles.txt scripts/wordcount.py
	python scripts/wordcount.py \
        --input_file=data/isles.txt \
        --output_file=results/isles.dat

results/abyss.dat : data/abyss.txt scripts/wordcount.py
python scripts/wordcount.py \
    --input_file=data/abyss.txt \
    --output_file=results/abyss.dat

results/last.dat : data/last.txt scripts/wordcount.py
    python scripts/wordcount.py \
        --input_file=data/last.txt \
        --output_file=results/last.dat

results/sierra.dat : data/sierra.txt scripts/wordcount.py
    python scripts/wordcount.py \
        --input_file=data/sierra.txt \
        --output_file=results/sierra.dat

# create the plots
results/figure/isles.png : results/isles.dat scripts/plotcount.py
	python scripts/plotcount.py \
        --input_file=results/isles.dat \
        --output_file=results/figure/isles.png

results/figure/abyss.png : results/abyss.dat scripts/plotcount.py
    python scripts/plotcount.py \
        --input_file=results/abyss.dat \
        --output_file=results/figure/abyss.png

results/figure/last.png : results/last.dat scripts/plotcount.py
    python scripts/plotcount.py \
        --input_file=results/last.dat \
        --output_file=results/figure/last.png

results/figure/sierra.png : results/sierra.dat scripts/plotcount.py
    python scripts/plotcount.py \
        --input_file=results/sierra.dat \
        --output_file=results/figure/sierra.png

# write the report
report/count_report.html : report/count_report.qmd \
results/figure/isles.png \
results/figure/abyss.png \
results/figure/last.png \
results/figure/sierra.png
    quarto render report/count_report.qmd

clean :
	rm -f results/isles.dat \
        results/abyss.dat \
        results/last.dat \
        results/sierra.dat
	rm -f results/figure/isles.png \
        results/figure/abyss.png \
        results/figure/last.png \
        results/figure/sierra.png
	rm -rf report/count_report.html
```

## Improving the Makefile

Adding `PHONY` targets to run parts of the analysis (e.g., just counting the words,
or just making the figures) can be very useful when iterating
and refining a particular part of your analysis.
Similarly, adding other PHONY targets to clean up parts of the analysis
can help with this as well.

In the version of the `Makefile` below we do just that,
creating the following PHONY targets:
- `dats` (counts words and saves to `.dat` files)
- `figs` (creates figures)
- `clean-dats` (cleans up `.dat` files)
- `clean-figs`(cleans up figure files)

```makefile
# Makefile
# Tiffany Timbers, Nov 2018

# This driver script completes the textual analysis of
# 3 novels and creates figures on the 10 most frequently
# occuring words from each of the 3 novels. This script
# takes no arguments.

# example usage:
# make all

# run entire analysis
all: report/count_report.html

# count words
dats: results/isles.dat \
results/abyss.dat \
results/last.dat \
results/sierra.dat

results/isles.dat : scripts/wordcount.py data/isles.txt
	python scripts/wordcount.py \
		--input_file=data/isles.txt \
		--output_file=results/isles.dat
results/abyss.dat : scripts/wordcount.py data/abyss.txt
	python scripts/wordcount.py \
		--input_file=data/abyss.txt \
		--output_file=results/abyss.dat
results/last.dat : scripts/wordcount.py data/last.txt
	python scripts/wordcount.py \
		--input_file=data/last.txt \
		--output_file=results/last.dat
results/sierra.dat : scripts/wordcount.py data/sierra.txt
	python scripts/wordcount.py \
		--input_file=data/sierra.txt \
		--output_file=results/sierra.dat

# plot
figs : results/figure/isles.png \
	results/figure/abyss.png \
	results/figure/last.png \
	results/figure/sierra.png

results/figure/isles.png : scripts/plotcount.py results/isles.dat
	python scripts/plotcount.py \
		--input_file=results/isles.dat \
		--output_file=results/figure/isles.png
results/figure/abyss.png : scripts/plotcount.py results/abyss.dat
	python scripts/plotcount.py \
		--input_file=results/abyss.dat \
		--output_file=results/figure/abyss.png
results/figure/last.png : scripts/plotcount.py results/last.dat
	python scripts/plotcount.py \
		--input_file=results/last.dat \
		--output_file=results/figure/last.png
results/figure/sierra.png : scripts/plotcount.py results/sierra.dat
	python scripts/plotcount.py \
		--input_file=results/sierra.dat \
		--output_file=results/figure/sierra.png

# write the report
report/count_report.html : report/count_report.qmd figs
	quarto render report/count_report.qmd

clean-dats :
	rm -f results/isles.dat \
		results/abyss.dat \
		results/last.dat \
		results/sierra.dat

clean-figs :
	rm -f results/figure/isles.png \
	results/figure/abyss.png \
	results/figure/last.png \
	results/figure/sierra.png

clean-all : clean-dats \
	clean-figs
	rm -f report/count_report.html
	rm -rf report/count_report_files
```

## Pattern matching and variables in a Makefile

It is possible to DRY out a Makefile and use variables.

Using wild cards and pattern matching in a makefile is possible, but the syntax is not very readable. So if you choose to do this proceed with caution. Example of how to do this are here: http://swcarpentry.github.io/make-novice/05-patterns/index.html

As for variables in a Makefile, in most cases we actually do not want to do this. The reason is that we want this file to be a record of what we did to run our analysis (e.g., what files were used, what settings were used, etc). If you start using variables with your Makefile, then you are shifting the problem of recording how your analysis was done to another file. There needs to be some file in your repo that captures what variables were called so that you can replicate your analysis. Examples of using variables in a Makefile are here: http://swcarpentry.github.io/make-novice/06-variables/index.html
